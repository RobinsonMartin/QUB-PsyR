[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About this site",
    "section": "",
    "text": "This site is work in progress. I will continuously add or update content\n\nContributors: - Thomas Schultze-Gerlach (t.schultze(at)qub.ac.uk)"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "R Space for QUB-Psy",
    "section": "",
    "text": "Welcome to the website. I hope you enjoy it!"
  },
  {
    "objectID": "intro1.html",
    "href": "intro1.html",
    "title": "R and RStudio",
    "section": "",
    "text": "R is a software for statistical analysis (among others), but we will not work with R directly. Instead, we will be using R via a software called Rstudio, which serves as a user interface. While there is nothing wrong with using R on its own, RStudio makes the life of the users easier."
  },
  {
    "objectID": "intro1.html#understanding-the-rstudio-interface",
    "href": "intro1.html#understanding-the-rstudio-interface",
    "title": "R and RStudio",
    "section": "Understanding the RStudio interface",
    "text": "Understanding the RStudio interface\nYou have got the latest version of R and RStudio on your computer and are eager to get things going? Great!\nIf you open R Studio for the first time, it will look like this:\n\n\n\nFig 1. RStudio interace when opening for the first time\n\n\nThe interface has three parts, the R console, the memory, and the utility and help area. Once you open your first R script (you can do do by clicking on “File”, selecting “New File”, and choosing “R Script”), a fourth (and probably the most important) appears in the top left, the script area (note; when you close all scripts, the script area will disappear again until a new script is opened).\n\n\n\nFig 2. RStudio interface when at least one script is open"
  },
  {
    "objectID": "intro1.html#the-rstudio-interface-components",
    "href": "intro1.html#the-rstudio-interface-components",
    "title": "R and RStudio",
    "section": "The RStudio interface components",
    "text": "The RStudio interface components\n\nThe console\nThe console is the direct link between RStudio and R. It executes the R code we enter, either manually or by running (part of) a script. With the exception of plots, the output of the code we entered, is also displayed in the console. We will be using the console mostly in the early states of getting used to working with R. We can execute code in the console by typing it in and confirming it via the “Enter” key. Doing so will directly produce the result of the code we entered (if we did it correctly) or an error message (if we managed to botch it up).\n\n\nThe memory\nThe memory area is one of the many advantages of using RStudio as compared to R only. It has different subsections. The subsection labeled Environment displays all the objects that are currently in R’s memory. Examples of such objects include variables we defined, data we read into R, or models we fit on our data. The list of objects in the Environment is rather handy because we do not need to memorize the names of all our objects, and we can even have a closer look at our more complex objects (e.g., we can have a look at the individual variables in our data object).\nThe second subsection is the History of our R session. The history contains all the code we sent to the console (irrespective of whether we did it by manually entering code in the console or by running a script). Using the History is handy if we want to trace back what we did, for example to search for errors.\n\n\nUtility and Help\nThe Utility and Help area located on the bottom right has five subsections, which can be tremendously helpful, so let’s have a closer look at them.\n\nFiles: This section displays the content of the current working directory. We can use it like the windows explorer to search for and load files.\nPlots: If we create plots, they will be displayed in this subsection.\nPackages: The base version of R comes with a wide range of functions that we can use to handle and analyse data. However, we will frequently want to do things that base R cannot do. In those situations, we will require additional R packages. The Packages section shows, which packages are installed on our computer, and which ones are currently active (more on that later).\nHelp: The Help section is very important. We can use it to obtain information on all functions and objects contained in base R and all currently active packages.\nViewer: We will rarely be using the Viewer when starting to learn R. It can be used to display local html-files that we can create using R.\n\n\n\nThe Script\nThe Script area in the top left of the interface is where we do most of our actual work. Here, we can create, save, load, and modify R scripts. If we open more than one script, each one will have its own tab displaying the name of the script (or labeling it as “unnamed” if we have not saved it yet). Clicking on the tabs lets us switch between scripts."
  },
  {
    "objectID": "intro2.html",
    "href": "intro2.html",
    "title": "Running code in R",
    "section": "",
    "text": "As mentioned before, the R console is where we execute code and where all the computing is done. Before we start using R scripts, we first need to get a rough understanding of what the R console does. Think of the console as a glorified calculator. You tell it to run a piece of code and then R returns the answer.\nThere are two ways to run code in R: entering it manually in the R console or writing a script and executing part or all of it."
  },
  {
    "objectID": "intro2.html#running-code-via-the-console",
    "href": "intro2.html#running-code-via-the-console",
    "title": "Running code in R",
    "section": "Running code via the console",
    "text": "Running code via the console\nWe can execute code by typing it in the console and hitting “Enter”. We will keep it simple for now. Lets say we want R to compute a few numbers. It could look like this:\n\n\n\nFig 1. Input and output of simple code in the R console\n\n\nAs we can see, each of the commands yields the appropriate answer. In theory, we could enter code that is much more complex, but entering long lines of code quickly becomes a hassle we would prefer to avoid. Also, once we close R we would have to enter the same code again manually, which is not only a lot of (unnecessary) work but also error prone.\n\nNote: Generally speaking, using the console directly to run code is not very sensible, the exception being queries using the help-function (more on the help-function later)."
  },
  {
    "objectID": "intro2.html#running-code-via-r-scripts",
    "href": "intro2.html#running-code-via-r-scripts",
    "title": "Running code in R",
    "section": "Running code via R scripts",
    "text": "Running code via R scripts\nThe most common way to run code in R is to write an R script and then execute it. The great advantage of an R script is that we can save it and re-run it as often as we want without having to enter everything by hand once again. If you are keen about Open Science, you can share the Script as part of your Open Analysis Code policy. Since R is free, researchers who want to look at, re-run, or even copy your code can do so without worrying about license fees.\nFor example, we can write a script containing the same computations we entered manually into the console above. To do so, we first need to create a new (end empty) R script by clicking on “File”, then on “New File” and selecting “R Script”.\n\n\n\nFig 2. Creating a new R script\n\n\nWe can now edit the script. Here, we enter each of the computations we want R to do as a single line of our script. Once all four lines are ready, we select them all (either by marking them with the mouse or by clicking ctrl+a). We then tell RStudio to run the selected code by clicking on the “Run”-button on the top right above the script or by pushing ctrl+Enter.\n\n\n\nFig 3. Running the code contained in the R script\n\n\nAs we can see, the output in the console looks as if we had manually entered the code and pressed “Enter” after each line. We could have obtained the same result by copy-pasting the content of the script into the console and hitting “Enter”.\nIn the image above, our script is yet unsaved as can be seen from its name “untitled1”. We can save it by clicking on the floppy disc Symbol (for those of you who still know what a 3.5” floppy disc is) or by clicking on “File” and then “Save” or “Save as”. Since we have not yet named our script, we will be prompted to select a name and to choose in which folder we want to save the script.\nFor example, we can name this script “my first script”. Once we have done that, the tab above the script shows the name of the script (or the start of the name if we chose a long name) followed by “.R” indicating that this is an R file.\n Also note how the name of the script is now shown in black font as opposed to the red font it had prior to saving. Writing a script’s name in red font is RStudio’s way of telling you that this script has unsaved changes."
  },
  {
    "objectID": "intro2.html#commenting-your-code",
    "href": "intro2.html#commenting-your-code",
    "title": "Running code in R",
    "section": "Commenting your code",
    "text": "Commenting your code\nOne crucial part of an R script are comments. Comments are used to explain the code we write. Commenting our scripts is very important as it provides structure to them and makes the code legible, be it for others who try to understand our code or to ourselves (trust me, you will learn to appreciate a well-commented code if you return to a script you wrote a few months back and cannot remember what you did there).\nWe can write comments by adding a # in front of the text. All text following a # in the same line will be ignored by R when running the script.\n\n\n\nFig 5. Running code with comments\n\n\nWhen running the script the whole code is copied to the console, but only the actual code is being evaluated. All the text that we declared as comments is being ignored.\n\nNote: A good rule of thumb is to have at least one line of comments for every four lines of code. When in doubt, opt for more or more detailed comments. Better to over-explain your code than to risk it being unintelligible."
  },
  {
    "objectID": "intro3.html",
    "href": "intro3.html",
    "title": "Objects and functions",
    "section": "",
    "text": "R revolves around objects and functions. Generally speaking, an object is a container for information, and a function is a piece of code that performs a specific task. We often use functions to manipulate or create objects."
  },
  {
    "objectID": "intro3.html#r-objects",
    "href": "intro3.html#r-objects",
    "title": "Objects and functions",
    "section": "R objects",
    "text": "R objects\nIn R, an object is information that we tore in R’s memory. In order to define an R object, we need to choose a name and tell R what information the object should contain. The general syntax for defining objects looks like this:\n\nobject_name = information\n\nWe write the name of our new object to the left of an equal sign and define the information the object should contain to its right. Instead of using an equal sign to define an object, we can also draw an arrow using the less than sign and a hyphen, which looks like this:\n\nobject_name <- information\n\n\nUsing the arrow instead of an equal sign dates back to an old programming language that R is derived from (APL). Whether you define objects using arrows or equal signs has no effect on what R does. It is simply a matter of preference.\n\nAs soon as we have defined an object (and assuming that we did everything correctly), our new object will appear in the Environment tab of RStudio’s Memory section (top right panel).\nWe will now cover the most important of the basic R objects, namely:\n\nsingle values\nvectors\nmatrices\n\n\nWe will later turn toward two of the more complex R objects that we are very likely to encounter frequently when working with R:\n\ndata frames\nlists"
  },
  {
    "objectID": "intro3.html#functions-in-r",
    "href": "intro3.html#functions-in-r",
    "title": "Objects and functions",
    "section": "Functions in R",
    "text": "Functions in R\nR functions are predefined pieces of code that we can call by writing the function name and telling R a number of function arguments. Function arguments are pieces of information a function needs to know in order to perform its task (very rarely, a function may not need any argument to perform its task). The general syntax for calling a function looks like this:\n\nfunction_name(argument1, argument2, ...)\n\nThat is, we first write the function’s name, and then define all required arguments in parentheses. If we do that correctly, the function will perform its task. Depending on the function, we will see an output in the console.\nWe will be using two functions below:\n\nThe function c, which we will use to create vectors. The arguments the function c requires are the elements we want to combine into a vector.\nThe function matrix, which creates a matrix from a vector. This functions requires a vector, the number of rows and the number of columns as arguments.\n\n\nCore fact 1: Functions can have a lot of arguments, but it is not always necessary to specify all of them. Most functions have default values for some of their arguments. If we do not specify these arguments, R will just run the function as if we had entered the default value of the argument. If we do specify arguments with default values, we simply override the default.\n\n\nCore fact 2: It is impossible (for most people at least) to remember all functions and which arguments they require. Therefore, R contains a lifesaver in the form of a special function called help. The function help requires the name of a topic (including but not limited to functions) as its main argument. Calling help with the name of a function will show the documentation for that function in the Help tab of the Utility & Help section of RStudio’s interface (bottom right)."
  },
  {
    "objectID": "intro3.html#object-types",
    "href": "intro3.html#object-types",
    "title": "Objects and functions",
    "section": "Object types",
    "text": "Object types\nSingle values, vectors, and matrices can vary by type. The type of these objects refers to the nature of its content, for example whether it contains numbers, character strings, logical arguments etc. The most common types of types are:\n\ndouble: this means numbers with decimal points (although the decimals must not necessarily be displayed)\ninteger: whole numbers that can be negative positive or zero (rarely used because double type numbers are more practical)\ncharacter: a character string, which is essentially a sequence of text symbols (these symbols can include numbers, but these are interpreted as being part of the text and not as numbers)\nlogical: a logical TRUE or FALSE, also called a boolean value"
  },
  {
    "objectID": "intro3.html#single-values",
    "href": "intro3.html#single-values",
    "title": "Objects and functions",
    "section": "Single values",
    "text": "Single values\nSingle values are the simplest type of objects we can define in R. As their name suggests, they represent a single value, for example, the number 7. We could tell R to create a single value called a that consists of the number 7. We do this as follows:\n\na = 7\n\nAlternatively, we can use the arrow notation to define the object.\n\na <- 7\n\nOnce we run either line of code, we should notice that our Environment now contains the object a. There, we can also see that a is the number 7.\nWe can make R show us an object by running its name as code (either via the console or a script). If we enter the name of our single value a as code, we will see the following output.\n\n\n\n[1] 7\n\n\n\nR tells us “7”, which is exactly the value that we specified as a. The “[1]” in front of the value “7” is not important at this point. It merely tells us that the “7” is the first (and only) element of our single value."
  },
  {
    "objectID": "intro3.html#vectors",
    "href": "intro3.html#vectors",
    "title": "Objects and functions",
    "section": "Vectors",
    "text": "Vectors\nVectors are objects that contain multiple values of the same type. Vectors cannot contain elements of different types. We can define vectors using the function c with the function’s arguments being the values we want to combine into the respective vector. The syntax looks as follow:\n\nv1 = c(1,2,3)   # This line of code creates a double vector \n                # called \"v1\" containing the numbers 1 to 3.\n\nv2 = c('hello', 'purple', '11!')  # This creates a character vector\n                                  # called \"v2\" containing three strings.\n\nAfter executing this code, our Environment contains two more objects, v1 and v2. The vector v1 is denoted as a numeric vector (num) whereas v2 is labeled as a character vector (chr).\nJust as with the single value a, we can have a look at our vectors by entering their names as code. For example, we can enter v2 as code.\n\n\n\n[1] \"hello\"  \"purple\" \"11!\"   \n\n\n\nWe now see the three character strings that v2 consists of in the console. Again, there is a [1] at the front of the line. It indicates that “hello” is the first element of v2. If the vector was long enough to occupy multiple rows in the console, each line would start with a number in brackets, indicating which element of the vector is displayed at the beginning of that line.\n\nFun fact: We can think of single values as vectors of length 1.\n\n\nCaveat: If we try to create a vector containing different types of elements, R will not complain (i.e., we do not get an error message)! Instead, R will simply transform some of the elements to ensure that all elements share the same type.\nFor example, if at least one of the elements we want to include in the vector is a character string, R will transform all other element types to character strings and create a character vector.\nIf we try to combine numeric (double or integer) and logical values into one vector, R will interpret “FALSE” as 0 and “TRUE” as 1."
  },
  {
    "objectID": "intro3.html#matrices",
    "href": "intro3.html#matrices",
    "title": "Objects and functions",
    "section": "Matrices",
    "text": "Matrices\nMatrices are the two-dimensional cousins of vectors. They have r rows and c columns. Per convention, the number of rows is stated before the number of columns, that is, a 4x3 matrix has 4 rows and 3 columns (think roman-catholic as a mnemonic aid).\nAs with vectors, all elements of a matrix must share the same type (if we try to combine different types of elements, R will just transform some of the elements to create a homogeneous matrix). In fact, matrices in R are vectors that we break down into rows and columns. To create a matrix, we need to call the function matrix and tell R three arguments: the vector we want to make into a matrix, the number of its rows, and the number of its columns. The syntax looks as follows:\n\nmatrix1 = matrix( # this tells R that we want to create a matrix\n  c(1,2,3,4),     # defines the vector that will turn into a matrix\n  nrow = 2,       # this tells R that our matrix should have 2 rows \n  ncol = 2)       # this tells R that our matrix should have 2 columns\n\nExecuting the code above creates a numerical matrix in our Environment. Other than with single values and vectors, we can click on the name of our matrix in the Environment to view how it looks like. Alternatively, we can enter the name of our matrix as code and have R print it in the console.\n\n\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\n\n\n\nR is convenient in the sense that it is technically sufficient to specify either the number of rows or the number of columns. R will just infer the missing piece of information. For example, if we want to turn a vector of length 6 into a matrix with 2 columns, R will know that the matrix must have 3 rows."
  },
  {
    "objectID": "intro3.html#naming-objects-in-r",
    "href": "intro3.html#naming-objects-in-r",
    "title": "Objects and functions",
    "section": "Naming objects in R",
    "text": "Naming objects in R\nIn order to define an object in R, we need to give it a name and then tell R how the object should look like. Generally speaking, we can get very creative when naming our objects, but there are a few rules we need to keep in mind.\n\nObject names must not start with numbers. The name “item2” is valid, but “2nd” is not (it will return a error message complaining about an “unexpected symbol”).\nObject names may not contain special characters with the exception of underscores and periods. For example, the names “item_2” or “item.2” are valid. Using other special character will often yield error messages because R interprets these characters as operators (e.g., “*” indicates multiplication, “&” is a logical conjunction, etc.).\nObject names must not contain spaces. While “item2” is a valid name, “item 2” is not.\n\n\nNot being allowed to use spaces in object names might prevent us from assigning meaningful and intelligible object names. To deal with the issue, there are three common types of notation:\n\nperiod notation: place periods where you would have placed a space, e.g. trial.number\nunderscore notation: replace spaces with underscores, e.g. trial_number\ncamelBack notation: instead of spaces write everything as one word, but write the beginning of new words with a capital letter, e.g. trialNumber\n\nWhich notation you use is purely a matter of preference. You will likely encounter all of them when using R because the people who created base R or additional packages each have their own preferences regarding notation."
  },
  {
    "objectID": "intro4.html",
    "href": "intro4.html",
    "title": "Data frames and lists",
    "section": "",
    "text": "Here, we will look at two types of R objects that we will frequently encounter when working R, data frames and lists. Both of these object types are a little more complex than the ones we talked about so far, but with greater complexity comes greater utility."
  },
  {
    "objectID": "intro4.html#data-frames",
    "href": "intro4.html#data-frames",
    "title": "Data frames and lists",
    "section": "Data frames",
    "text": "Data frames\nData frames are R objects specifically designed for people who work with data. Just like matrices, they are two-dimensional objects. The main difference, however, is that data frames can contain different types of elements. To be exact, data frames are a combination of different vectors of the same length.\nThe general idea of a data frame is to view every row as an observation and every column as a variable. Therefore, each column represents a vector, which also means that, column-wise, all elements must be of the same type. The same is not true for the rows of a data frame.\n\nHow to define a data frame\nWe can define data frames by calling the function data.frame and entering vectors or matrices as function arguments. Here, vectors are treated as column vectors (or nx1 matrices, if you will). The only requirement is that all of the vectors and matrices we want to combine into a data.frame have the same number of rows.\nBelow is very simple example of how we can define a data frame in R. Imagine, we have collected data from 5 participants, which we will identify by the numbers from 1 to 5, and that we asked them to report their gender (open response) and age in years (numeric value).\n\nmy_data_frame = data.frame(\n  c(1, 2, 3, 4, 5),                                       # participant ID\n  c('male', 'female', 'non-binary', 'female', 'female'),  # participant gender\n  c(25, 19, 23, 22, 28)                                   # participant age\n)\n\n\nNote: In this example, the code is distributed across several lines. Technically, we could have written it all in one long line, but doing so makes it very difficult to read the code. Unless we call a function with few or very short function arguments, it is recommended to use one line for each argument.\nAlso note how the function arguments are shifted a bit to the right. This is called indentation. Indentation has no effects on how the code works in R (it does in other programming languages such as Python!). However, it contributes greatly to the legibility of the code by structuring it.\nIt is, therefore, a good idea to get used to organizing longer pieces of code by using multiple lines and proper indentation. Your future self, your collaborators, and third parties, who will read your code when you make it publicly available, will thank you for it.\n\nOnce we execute the piece of code above, the data frame will appear as an object in RStudio’s Environment (top right). We can immediately see that it is a data frame because RStudio describes data frames as x observations of y variables. In our case that is listed as “5 obs. of 3 variables”.\n\nNote: The Environment will show a small light blue button with a white arrowhead to the left of our data frame’s name. If we click this button, RStudio will “unfold” the data frame and show us a list of the vectors it contains as well as the type of the vector.\n\nJust as with matrices, we can have a look at our new object by either entering its name or by clicking on it in the environment. If we do the former, R will return the data frame in the console, whereas the latter will open the data frame in a separate tab next to our scripts. Let’s go with the code version.\n\n\n\n  c.1..2..3..4..5. c..male....female....non.binary....female....female..\n1                1                                                  male\n2                2                                                female\n3                3                                            non-binary\n4                4                                                female\n5                5                                                female\n  c.25..19..23..22..28.\n1                    25\n2                    19\n3                    23\n4                    22\n5                    28\n\n\n\n\n\nAssigning proper variable names\nWe may notice two things: first, the data frame contains exactly the information we specified as function arguments for the data.frame function; second, each column of our data frame has a very weird name. The reason is that data frames require variable names for each column, and if we do not specify these names, R will just use each vector’s content as a name. This is inconvenient for a number of reasons, so it is desirable to assign proper names to the variables.\nOne way to do so is calling the function names, which allows us to change the names of a data frame’s variables. The function ‘names’ requires the name of the data frame as a function argument. We then define it as a character vector containing the new variable names. The character vector must contain one element for each column of the data frame. For our data frame, it could look like this:\n\nnames(my_data_frame) = c('ID', 'gender', 'age')\n\nIf we now ask R to show us the data frame in the console (by entering its name as code), it will look much tidier.\n\n\n\n  ID     gender age\n1  1       male  25\n2  2     female  19\n3  3 non-binary  23\n4  4     female  22\n5  5     female  28\n\n\n\nAnother way to assign sensible variable names is to specify them when creating the data frame. We can do so by making slight adjustments to the way we enter vectors as function arguments when calling the data.frame function. In fact, the code will look as if we define vectors as objects. The only difference is that when doing so within the data.frame function, the vectors will not be created outside the data frame (i.e., they will not appear as separate objects in the Environment). Here is what the code would look like for our data frame.\n\nmy_data_frame = data.frame(  \n  ID = c(1, 2, 3, 4, 5),                                          # ID\n  gender = c('male', 'female', 'non-binary', 'female', 'female'), # gender\n  age = c(25, 19, 23, 22, 28)                                     # age\n) \n\nThe result is the same as if we had used the names function.\n\n\n\n  ID     gender age\n1  1       male  25\n2  2     female  19\n3  3 non-binary  23\n4  4     female  22\n5  5     female  28\n\n\n\n\n\nEntering matrices into data frames\nAs mentioned above, we can also enter matrices as function arguments when creating a data frame, as long as these matrices have the correct number of rows. Let’s assume that we additionally collected responses from two Likert scale items (levels 1 to 5), which we would like to enter into our data frame. Our code would then look like this:\n\nmy_data_frame = data.frame(  \n  ID = c(1, 2, 3, 4, 5),                                          # ID\n  gender = c('male', 'female', 'non-binary', 'female', 'female'), # gender\n  age = c(25, 19, 23, 22, 28),                                    # age\n  matrix(c(1, 3, 5, 4, 3, 5, 5, 3, 2, 2), nrow = 5)               # responses \n) \n\nRunning this code creates a data frame with 5 observations of 5 variables in in the environment. One problem is that we cannot name the two new variables contained in the matrix as we did with the vectors. However, when we look at our data frame, we will notice that the variable names do not look as terrible as they did when we entered the unnamed vectors. Instead, the variables will be named “X1” and “X2” (when entering a matrix, R will just assign the names from “X1” to “Xi” for a matrix with i columns).\nStill, we might prefer less obscure names for our two measures. One possibility is to use the names function as we did above. Another is to create the matrix as a separate object before creating the data frame. This allows us to set proper column names using the function colnames. This function works very similar to the names function but is specifically designed for matrices. Here is what the code would look like.\n\n# First, we create our 5x2 matrix as an object\nresponse_matrix = matrix(\n  c(1, 3, 5, 4, 3, 5, 5, 3, 2, 2), \n  nrow = 5\n)\n\n# Next, we assign column names\ncolnames(response_matrix) = c('item1', 'item2')\n\n# Finally, we create the data frame\nmy_data_frame = data.frame(  \n  ID = c(1, 2, 3, 4, 5),                                          # ID\n  gender = c('male', 'female', 'non-binary', 'female', 'female'), # gender\n  age = c(25, 19, 23, 22, 28),                                    # age\n  response_matrix                                                 # responses \n) \n\nThe new variables in our data frame now have proper names. We can check this by calling the name of our data frame and inspecting it in the console (or by clicking on its name in the Environment).\n\n\n\n  ID     gender age item1 item2\n1  1       male  25     1     5\n2  2     female  19     3     5\n3  3 non-binary  23     5     3\n4  4     female  22     4     2\n5  5     female  28     3     2\n\n\n\n\nDefining objects outside a data frame and then simply using their name as a function argument when calling the data.frame function is not limited to matrices but can also be done for vectors. While there are good reasons for defining objects separately before combining them into a data frame, one downside is that our Environment can get a wee bit cluttered.\nIf we want to tidy up our environment, we can remove objects we no longer need (for example, because we put them into a data frame) using the function rm. We simply need to use the name of the object we want to remove as the function argument for rm, and it will be disappear from the Environment."
  },
  {
    "objectID": "intro4.html#lists",
    "href": "intro4.html#lists",
    "title": "Data frames and lists",
    "section": "Lists",
    "text": "Lists\nThe final type of R object we need to know for now is the list. Lists are very flexible containers that we can create using the list function. Think of lists as multi-purpose storage units. They can contain all other types of R objects (including other lists). For example, we could create a list that contains a single character string, a numeric vector, and a data frame. To do so, we simply call the function list and enter each object we want to store in the list as a function argument.\n\nmy_value = 'hello'          # a single character value\nmy_vector = c(1,1,2,3,5,8)  # a numeric vector\n\n# The following code creates a list with three elements\nmy_list = list(\n  my_value,\n  my_vector,\n  my_data_frame\n)\n\nrm(my_value, my_vector)   # this removes two of the objects from the environment\n\nAs with other objects, the new list will appear in the Environment. RStudio tells us that this object is a list of 3. Just like for a data frame, there is a small light blue button to its left that allows us to unfold the list and have a look at its contents.\nWe can also click on the list in the environment to have a look at it or have R print the list in the console by calling its name. If we do the latter, the output looks like this:\n\n\n\n[[1]]\n[1] \"hello\"\n\n[[2]]\n[1] 1 1 2 3 5 8\n\n[[3]]\n  ID     gender age item1 item2\n1  1       male  25     1     5\n2  2     female  19     3     5\n3  3 non-binary  23     5     3\n4  4     female  22     4     2\n5  5     female  28     3     2\n\n\n\nAs we can see, the output lists the elements of our list one after another. The first element of the list is preceded by “[[1]]”, the second by “[[2]]”, and so on.\n\nNote: Once we start analysing data in R, we will frequently encounter lists. The reason is that many R functions used in inferential statistics use lists as outputs."
  },
  {
    "objectID": "working1.html",
    "href": "working1.html",
    "title": "Binary Operators",
    "section": "",
    "text": "We already know ho to define R objects. We will now turn to the question how to work with them. Generally speaking, we can work with R objects by performing operations on them. There are two ways of doing so: one is to use binary operators. Another way to perform operations on R objects is to feed them into functions as function arguments. Here, we will focus on binary operators.\nBinary operators are symbols that R uses to represent a specific operation involving two objects. These operations can be arithmetic or logical. Before we jump into action, we need to have a look at how R’s binary operators look like."
  },
  {
    "objectID": "working1.html#arithmetic-binary-operators",
    "href": "working1.html#arithmetic-binary-operators",
    "title": "Binary Operators",
    "section": "Arithmetic binary operators",
    "text": "Arithmetic binary operators\nR has seven built-in arithmetic binary operators (you will probably not use the last two, but we will include them for the sake of completeness).\n\n\n\n\n\n\n\n\nOperator\nOperation\nWhat R does\n\n\n\n\n+\naddition\ncomputes the sum of two numbers\n\n\n-\nsubtraction\nsubtracts the second number from the first\n\n\n*\nmultiplication\ncomputes the product of two numbers\n\n\n-\ndivision\ndivides first number by the second\n\n\n^\npower\ntakes the first to the power of the second\n\n\n%%\nmodulo\ntakes the remainder of division\n\n\n%/%\ninteger division\ndivision rounded down to whole numbers"
  },
  {
    "objectID": "working1.html#logical-binary-operators",
    "href": "working1.html#logical-binary-operators",
    "title": "Binary Operators",
    "section": "Logical binary operators",
    "text": "Logical binary operators\nBesides arithmetic operators, R has several built-in logical binary operators. Logical binary operators also require two objects as arguments. They compare the object to the left of the operator to the object on its right and check if the result of this comparison is TRUE or FALSE. In other words, they return a Boolean value. Here is the list of logical operators:\n\n\n\n\n\n\n\nOperator\nWhat R tests\n\n\n\n\n<\nthe first value is less than the second\n\n\n<=\nthe first value is less than or equal to the second\n\n\n>\nthe first value is greater than the second\n\n\n>=\nthe first value is greater than or equal to the second\n\n\n==\nthe first value is exactly equal to the second\n\n\n!=\nthe first value is not equal to the second\n\n\n\n\nUsing binary operators on single values\nThe simplest way to use binary operators is to use them on single values. In the case of arithmetic operators, this comes down to adding, subtracting, multiplying etc. two numbers. As the two arguments for the operators, we can use values we defined as objects prior to the operation, values that we enter as is, or a combination of both. Here are a few examples.\n\na = \"hello\"   # a character value\nb = FALSE     # a Boolean value\nd = 13        # a numeric value\ne = 2         # another numeric value\n\na != \"hello\"  # tests if a is unqeual to the string \"hello\" (this is FALSE)\n\nb == FALSE    # tests if b is the Boolean value FALSE (which is TRUE)\n\nd + 3         # adds 3 to the object d (for a total of 10)\n\nd ^ e         # takes d to the power of e (the result is 169)\n\nThis is what appears in the console:\n\n\n\n[1] FALSE\n\n\n[1] TRUE\n\n\n[1] 16\n\n\n[1] 169\n\n\n\n\nNote In the example above, we named the four objects a, b, d, and e. This was neither an oversight nor an expression of dislike toward the letter c. The simple reason is that there is a function called c, and it is prudent to avoid giving objects the same name as existing functions.\nTechnically, it is possible to assign an object the name of a function, but it may lead to confusion or problems with the R code. Therefore, it is best avoided.\n\nWe can create more complex operations by combining multiple arithmetic and/or logical operators involving multiple values, and we can save the result by defining it as another object.\n\nNote that R follows the basic rules of arithmetic operations. That is, power takes precedence over multiplication or division, which, in turn, take precedence over addition or subtraction. Just as in school maths, we need to use parentheses to organize our operations accordingly.\nWe can also use parentheses in the same fashion when combining multiple logical operations.\nWhen combining arithmetic and logical operators, the arithmetic operations take precedence over the logical ones.\n\nExample 1:\n\nx = 3   # define a numeric value\ny = 2   # define another value\n\nz = x ^ 2 / (x * y - x)\n\nIn the example above, we defined a numeric value called z. Since power takes precedence over division, R first computes x to the power of 2 (for a total of 9). It then divides 9 by the expression in the parentheses. Within the parentheses, multiplication takes precedence over subtraction, which means that R first computes the product of x and y (which is 6) and then subtracts x for a total of 3. So our code boils down to dividing 9 by 3. We can easily verify that R did that by inspecting the new object z.\n\nz\n\n\n\n\n[1] 3\n\n\n\nExample 2:\n\nx = 3      # define a numeric value\ny = 2      # define another value\nz = 'red'  # define a character value\n\nz != 'red' & (x > 2 | x + y == 7)\n\nIn this example, we test whether the two conditions combined by & (logical AND) are simultaneously TRUE. First, whether the value z equals the string ‘red’, and second, whether at least one of the following two statements combined with the | (logical OR) is TRUE: the value x is greater than 2 OR the sum of x and y equals 7.\nThe first statement is TRUE because z equals the character string ‘red’. The second statement is also true. While the sum of x and y clearly differs from 7 and is, thus, FALSE, x is greater than 2. Since the logical OR only requires one of the statements to be TRUE, the whole statement in parentheses is TRUE. Therefore, executing this code should return the Boolean TRUE, which we can check by inspecting the output in the console.\nIt looks as follows:\n\n\n[1] TRUE\n\n\n\nIn theory, arithmetic operators should only work on numeric values (integer or double). Accordingly, R will complain if at lest one of the objects we use as arguments is a character string. Specifically, it will return an error message in the console stating that we assigned a non-numeric argument to the binary operator.\nSomething similar should happen if we assign at least one Boolean value, that is, a value stating either a logical TRUE or FALSE. Keep in mind, however, that R sometimes changes the type of an object so that it works with an operator or function (this is called coercion). If we use a Boolean value in an arithmetic operation, R will just treat it as a binary numeric variable (FALSE = 0, TRUE = 1).\n\n\n\nUsing binary operators on vectors and matrices\nWe can also use binary operators on vectors or matrices. The exact operation depends on the two objects involved. More specifically, if one of the two arguments of a binary operator is a vector or a matrix, then the operation differs depending on whether the second argument is a single vector or another vector or matrix.\nLets first look at the (simpler) case where one of the two arguments is a vector/matrix and the other is a single value. In this case, the exact same operation is performed on all elements of the vector or matrix. For example adding a single value and a vector/matrix means that the single value is added to each element of the vector/matrix, multiplying the vector/matrix by a number means that each element is multiplied by that number, testing whether a vector/matrix equals a certain character string tests for each element whether it equals that string, and so on. Let’s look at some examples.\n\nv1 = c('red', 'green', 'blue')  # defines a character vector\n\nm1 = matrix(1:9, nrow = 3)      # defines a numeric 3x3 matrix\n\na = 2         # defines a numeric value\n\nv1 == 'red'   # tests for each element of v1 whether it equals the string 'red'\n\na ^ m1        # takes a (the value 2) to the power of each element of m1\n\nm1 < 5        # tests for each element of m1 whether it is smaller than 5   \n\nThis is what appears in the console:\n\n\n\n[1]  TRUE FALSE FALSE\n\n\n     [,1] [,2] [,3]\n[1,]    2   16  128\n[2,]    4   32  256\n[3,]    8   64  512\n\n\n     [,1]  [,2]  [,3]\n[1,] TRUE  TRUE FALSE\n[2,] TRUE FALSE FALSE\n[3,] TRUE FALSE FALSE\n\n\n\nIrrespective of whether we enter the vector/matrix as the first or the second argument of the binary operator, the output has the same size and dimensions. That is, multiplying a vector of length 4 by a number yields a numeric vector of length 4. Multiplying a 3x3 matrix by a number yields another numeric 3x3 matrix. Testing whether a statement is true for a vector of length 7 returns a Boolean vector of length 7, and so on.\nWe can also use binary operators with both arguments being vectors or matrices. As a general rule, we must use objects of equal size in those operations, that is, if the object to the left of the operator is a vector of length 6, then the object to its right must also be a vector of length 6. Likewise, if we enter a 3x4 matrix to the left of the operator, our argument on its right will also have to be a 3x4 matrix.\n\nCaveat: While R complains when we enter two matrices of unequal size as arguments of a binary operator (it will print an error message in the console), the same is not true for vectors. If we sue binary operators on vectors of unequal length, R will simply extend the shorter vector by starting over.\nFor example, when adding a vector containing the numbers from 1 to 3 to another vector containing the numbers from 1 to 5, R will turn the first vector into a vector of length 5 by repeating the first two elements (the resulting vector then has the elements 1, 2, 3, 1, 2).\nThis built-in feature of R can cause problems because situations, in which we actually want to perform binary operations on vectors of unequal length, are rare. Since R will run the code without any complaints, we run the risk of missing bugs in our code. Therefore, it is prudent to double-check the code whenever we use binary operators with two vectors.\n\nWhen using binary operators with two vectors or matrices, R performs an element-wise operation. That means that R pairs the first element of the first vector or matrix with the corresponding element of the second vector or matrix when performing the operation. The second element of the first object is paired with second element of the second object, and so on. Let’s again look at a few examples.\nVectors first.\n\nv1 = c(2, 4, 6, 8)    # defines a numeric vector\n\nv2 = 1:4              # lazy way of creating a vector of length 4\n\nv1 + v2               # performs element-wise addition of the vectors\n\nv1 != v2              # takes each element of v1 abnd tests whether it is\n                      # different from the corresponding element of v2\n\nThis is what appears in the console:\n\n\n\n[1]  3  6  9 12\n\n\n[1] TRUE TRUE TRUE TRUE\n\n\n\nNow for some matrices.\n\nm1 = matrix(c(2, 4, 6, 8), nrow = 2)    # defines a 2x2 matrix\n\nm2 = matrix(1:4, ncol = 2)              # defines another 2x2 matrix\n\nm1 - m2               # performs element-wise subtraction of the matrices\n\nm1 < m2               # takes each element of m1 tests whether it is less than \n                      # the corresponding element of m2   \n\nThis is what appears in the console:\n\n\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\n\n      [,1]  [,2]\n[1,] FALSE FALSE\n[2,] FALSE FALSE\n\n\n\nAs we can see, performing arithmetic operations on matrices using binary operators yields numeric matrices of the same size as the input matrices as result. When using logical binary operators instead, the result will be a Boolean matrix of equal size as the two input matrices.\n\nNote that using the binary operator for multiplication (*) on matrices does not do what we would expect from regular matrix algebra. If we want to do classic matrix multiplication, we need to use a special operator, namely %*%."
  },
  {
    "objectID": "working2.html",
    "href": "working2.html",
    "title": "Functions",
    "section": "",
    "text": "Most of the things we will do when using R will be done using functions. We can think of a function as an (often) elaborate sequence of simple operations. As such, they can involve more than two objects. However, functions are not only more elaborate than operations using a binary operator; they are also more flexible, because we can modify what a function does or how it does it via its additional function arguments."
  },
  {
    "objectID": "working2.html#the-basic-setup-of-r-functions",
    "href": "working2.html#the-basic-setup-of-r-functions",
    "title": "Functions",
    "section": "The basic setup of R functions",
    "text": "The basic setup of R functions\nAll R function share the same setup. The function has a unique name by which we can call it, and it has a number of function arguments that we need to specify in parentheses following the function name when calling the function.\nFunction arguments can be objects that we would like to feed to the function or parameters of the function that influence what the function does. Some of a function’s arguments are required arguments, that is, if we do not specify these arguments, the functions won’t run. Instead, R will complain by printing an error message telling us that we did not specify a required function argument.\nA function may also entail non-required function arguments. Technically, these arguments are also required, but the person who wrote the function defined default values for the arguments. If a function argument has a default value, we do not need to specify it in order for the function to run. The function will simply run as if we had entered the respective argument’s default value manually.\n\nOccasionally, we might come across functions that have no arguments at all. These functions are quite rare. We can can them by writing nothing in the parentheses following the function’s name."
  },
  {
    "objectID": "working2.html#the-most-useful-function-in-r---help",
    "href": "working2.html#the-most-useful-function-in-r---help",
    "title": "Functions",
    "section": "The most useful function in R - help",
    "text": "The most useful function in R - help\nAll functions in R are documented in order to help users understand what the function does, what its arguments are and what they do. We can ask R to show us the documentation using the function help. If we call this function and feed it the name of an R function as a function argument, R will display the documentation in the help tab of the utility & help section (bottom right of RStudio’s interface). Note that the function help requires the function name to be a character string, that is, we need to write it in quotation marks.\nAs an alternative to calling the function’s name in regular R syntax, we can type the functions name in the search bar of the help tab.If we use this way to learn about a function, we do not need quotation marks.\nOnce we call the help function, R will show us the documentation of an existing R function or a group of related functions. R will generally display a lot of information. What information is displayed exactly depends on the function.\nThe following information will be shown for all functions:\n\nthe name of the function\nwhat R package it is from\na description of the the function does\nhow to call the function (usage)\nthe functions’ arguments\na description of the type and format of the function’s output (value)\nfunctioning R code showing examples of how the function can be used\n\nThere may be additional information for some functions such as: - a description of the maths or logic underlying the function (details) - additional information of potential interest to the user (note) - references to literature the literature the function is based on - links to related functions (see also)\nLet’s look at an example by asking R to show us the documentation for the function median using R syntax.\n\nhelp(\"median\")\n\nR will now show us the following in the help tab.\n\n\n\nFig 1. Documentation for the function median\n\n\nLet’s first look at the description. Unsurprisingly, it states that this function computes the sample median.\nOne of most relevant sections of the documentation is the function’s usage. As we can see, the function median has two function arguments, x and na.rm. The second argument, na.rm has a default value, indicated by the equal sign and a specific value (FALSE) to its right. If we do not specify na.rm, R will use the value FALSE as a default. Since the argument x has no default, we must specify it. Otherwise, the function won’t run.\nThe other highly relevant section is the arguments section. It tells us what the function arguments do and values are acceptable for each of the two function arguments. The argument x must be a numeric vector (we can ignore the first part of the sentence referring quite obscurely to ‘an object for which a method has been defined’). This is the set of numbers for which we will compute the median. The second function argument, na.rm, defines how missing values (represented by NA, meaning “not available”) should be handled. The function will not work when our numeric vector x contains at least one NA value. By setting na.rm to TRUE, we can tell R to remove the NA values prior to computing the median.\nFinally, let’s inspect the value section. From what the function is supposed to do, we would expect it to return a single numeric value. The documentation tells us that this value can be a double type value when the vector is of even length (in this case, the median is the mean of the two centremost values of x). It also informs us that the output of the function will be NA if x is either an empty vector of if x contains NA values while na.rm is set to FALSE.\n\nAt the top left of the documentation, R states in braces following the function’s name which R package it stems from. In case of the function median, the package it belongs to is called stats. This package along with base is built into core R.\nCaveat: If a function does not belong to one of R’s built-in packages, R’s help will not know the function unless the respective package is loaded (see the section on installing and loading additional packages for more information)."
  },
  {
    "objectID": "working2.html#finding-functions-if-their-name-is-unknown",
    "href": "working2.html#finding-functions-if-their-name-is-unknown",
    "title": "Functions",
    "section": "Finding functions if their name is unknown",
    "text": "Finding functions if their name is unknown\nSometimes, we might be looking for a function to perform a specific operation, but we do not know whether R has such a function and, if so, how it is called in R. In such situations, we can make use of the search bar on the top right of the help tab. If we input the term we are interested in there, R will return a list of related functions in the help tab.\nLet’s assume, for example, that we are looking for a function that computes the standard deviation of a numeric vector. Entering the term “standard deviation” in the search bar, yields the following output:\n\n\n\nFig 2. Search results for the term “standard deviation”\n\n\nAs we can see, R links to several help pages, each of which contains the documentation for a function that R thinks to relate to our search term. R displays the results of the search in a special format, namely package name::function name. For example, the first result of the search is the function devfun2 of the package lme4. Klicking on any of the links our search returned is equivalent to using the help function for the respective function.\n\nNote that unlike the regular help function, using the search bar is not restricted to currently loaded R packages. Any package that is installed on the computer will be included in the search. This handy feature is designed to maximize the chance of finding the function we are looking for.\n\nIn the example above, we can see that there is a function called sd in the stats package that is part of basic R. The brief description of this function looks promising enough to warrant klicking on the function’s name. The documentation for the function that R now displays confirms that this is the function we are looking for (see below).\n\n\n\nFig 3. Documentation for the function sd\n\n\nAs we can see from the documentations usage and arguments sections, the function sd requires a numeric vector x as a function argument. It has a second optional argument we are already familiar with, namely na.rm, which allows us to exclude NA values prior to computing the standard deviation.\nLet’s have a look at the details section of the function sd. This section contains an important piece of information, namely that the function uses the denominator \\(n-1\\). What this means is that the function sd computes an unbiased estimate of the population standard deviation by multiplying the (uncorrected) sample variance by \\(\\frac{n}{n-1}\\) prior to taking its square root.\nAn alternative to using the search bar of the help tab is to use R code to search for functions. We can do so using a special operator ?? followed by the term we are searching for. If our term consists of more than one word, we need to put it in quotation marks (putting a single word in quotation marks won’t do any harm).\nThe syntax looks like this:\n\n??\"standard deviation\"\n\nWe can verify that searching for our term of interest using R syntax yields the same results in the help tab.\n\nCaveat: There is one situation in which using the search bar of the help tab and using the operator ?? will yield different results. If the search term matches the name of an R function, either from base R or from a currently loaded R package, the help tab will always display the documentation for that function instead of providing us with a list of potentially relevant functions. Using the ?? operator will always display the list of results.\n\n\nIf our search for the desired function is not successful, google (or any non-evil alternative search engine) is our friend. R has a very active and supportive community, and there are extensive resources for R users online."
  },
  {
    "objectID": "working_x.html",
    "href": "working_x.html",
    "title": "Custom functions",
    "section": "",
    "text": "Writing R functions is easy, once we understand how R functions work (and we do know that from looking at the documentation of different functions). What we need to do when defining a custom function is to: - give it a name (ideally a unique name to avoid conflicts with existing functions) - tell R what function arguments the function should have - tell R whether any of the arguments should have default values - tell R what operations it should perform when we call the function\nWhen defining the function, we need to use a specific Syntax. Just as with R objects, we write the name of our custom function to the left of an equal sign. To its right we call the function function. This function does not have fixed arguments that we specifiy in parentheses. Instead, we write those arguments in parentheses that we want our our custom function to have. If we would like there to be a default value for a function argument, we can use an equal sign following the argument name and enter the respective value to its right.\nFinally, we use braces to define what the function should do, that is, which operations to run on the arguments we fed it. Here, sky is the limit to our creativity. We can use any binary operator or function (even other custom functions) to tell R what it it should do. The final line of code within the braces should be a call of the function return, which we can use to define the output of our custom function. Let’s look at a few examples.\n\nExample 1\nIn the firstexample, we will write a custom function that computed the uncorrected standard deviation of a numeric vector (remember that the function sd that is built into base R computed the bias-corrected standard deviation, which may not always be what we are looking for). We will call this function sd_uncorrected (any name is fine, but it may be prudent to choose a name that is informative of what the function does).\nThe R code for defining this function could look as follows:\n\nsd_uncorrected = function(x, na.rm = TRUE){\n  \n  x = na.omit(x)  # excludes elements of x that are NA (if any)\n  n = length(x)   # sample size n is the length of the vector x\n  \n  var_x = 1/n * sum((x - mean(x))^2)  # compute uncorrected variance of x\n  sd = sqrt(var_x)                    # take square root to get sd\n  \n  return(sd)                          # return the object sd, which happens to be\n                                      # a single numeric value\n  \n}"
  }
]