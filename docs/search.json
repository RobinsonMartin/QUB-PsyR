[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About this site",
    "section": "",
    "text": "This site is work in progress. I will continuously add or update content\n\nContributors: - Thomas Schultze-Gerlach (t.schultze(at)qub.ac.uk)"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "R Space for QUB-Psy",
    "section": "",
    "text": "Welcome to the website. I hope you enjoy it!"
  },
  {
    "objectID": "intro1.html",
    "href": "intro1.html",
    "title": "R and RStudio",
    "section": "",
    "text": "Understanding the RStudio interface\nYou have got the latest version of R and RStudio on your computer and are eager to get things going? Great!\nIf you open R Studio for the first time, it will look like this:\n\n\n\nFig 1. RStudio interace when opening for the first time\n\n\nThe interface has three parts, the R console, the memory, and the utility and help area. Once you open your first R script (you can do do by clicking on “File”, selecting “New File”, and choosing “R Script”), a fourth (and probably the most important) appears in the top left, the script area (note; when you close all scripts, the script area will disappear again until a new script is opened).\n\n\n\nFig 2. RStudio interface when at least one script is open\n\n\n\n\nThe RStudio interface components\n\nThe console\nThe console is the direct link between RStudio and R. It executes the R code we enter, either manually or by running (part of) a script. With the exception of plots, the output of the code we entered, is also displayed in the console. We will be using the console mostly in the early states of getting used to working with R. We can execute code in the console by typing it in and confirming it via the “Enter” key. Doing so will directly produce the result of the code we entered (if we did it correctly) or an error message (if we managed to botch it up).\n\n\nThe memory\nThe memory area is one of the many advantages of using RStudio as compared to R only. It has different subsections. The subsection labeled Environment displays all the objects that are currently in R’s memory. Examples of such objects include variables we defined, data we read into R, or models we fit on our data. The list of objects in the Environment is rather handy because we do not need to memorize the names of all our objects, and we can even have a closer look at our more complex objects (e.g., we can have a look at the individual variables in our data object).\nThe second subsection is the History of our R session. The history contains all the code we sent to the console (irrespective of whether we did it by manually entering code in the console or by running a script). Using the History is handy if we want to trace back what we did, for example to search for errors.\n\n\nUtility and Help\nThe Utility and Help area located on the bottom right has five subsections, which can be tremendously helpful, so let’s have a closer look at them.\n\nFiles: This section displays the content of the current working directory. We can use it like the windows explorer to search for and load files.\nPlots: If we create plots, they will be displayed in this subsection.\nPackages: The base version of R comes with a wide range of functions that we can use to handle and analyse data. However, we will frequently want to do things that base R cannot do. In those situations, we will require additional R packages. The Packages section shows, which packages are installed on our computer, and which ones are currently active (more on that later).\nHelp: The Help section is very important. We can use it to obtain information on all functions and objects contained in base R and all currently active packages.\nViewer: We will rarely be using the Viewer when starting to learn R. It can be used to display local html-files that we can create using R.\n\n\n\nThe Script\nThe Script area in the top left of the interface is where we do most of our actual work. Here, we can create, save, load, and modify R scripts. If we open more than one script, each one will have its own tab displaying the name of the script (or labeling it as “unnamed” if we have not saved it yet). Clicking on the tabs lets us switch between scripts."
  },
  {
    "objectID": "intro2.html",
    "href": "intro2.html",
    "title": "Running code in R",
    "section": "",
    "text": "As mentioned before, the R console is where we execute code and where all the computing is done. Before we start using R scripts, we first need to get a rough understanding of what the R console does. Think of the console as a glorified calculator. You tell it to run a piece of code and then R returns the answer.\nThere are two ways to run code in R: entering it manually in the R console or writing a script and executing part or all of it."
  },
  {
    "objectID": "intro2.html#running-code-via-the-console",
    "href": "intro2.html#running-code-via-the-console",
    "title": "Running code in R",
    "section": "Running code via the console",
    "text": "Running code via the console\nWe can execute code by typing it in the console and hitting “Enter”. We will keep it simple for now. Lets say we want R to compute a few numbers. It could look like this:\n\n\n\nFig 1. Input and output of simple code in the R console\n\n\nAs we can see, each of the commands yields the appropriate answer. In theory, we could enter code that is much more complex, but entering long lines of code quickly becomes a hassle we would prefer to avoid. Also, once we close R we would have to enter the same code again manually, which is not only a lot of (unnecessary) work but also error prone.\n\nNote: Generally speaking, using the console directly to run code is not very sensible, the exception being queries using the help-function (more on the help-function later)."
  },
  {
    "objectID": "intro2.html#running-code-via-r-scripts",
    "href": "intro2.html#running-code-via-r-scripts",
    "title": "Running code in R",
    "section": "Running code via R scripts",
    "text": "Running code via R scripts\nThe most common way to run code in R is to write an R script and then execute it. The great advantage of an R script is that we can save it and re-run it as often as we want without having to enter everything by hand once again. If you are keen about Open Science, you can share the Script as part of your Open Analysis Code policy. Since R is free, researchers who want to look at, re-run, or even copy your code can do so without worrying about license fees.\nFor example, we can write a script containing the same computations we entered manually into the console above. To do so, we first need to create a new (end empty) R script by clicking on “File”, then on “New File” and selecting “R Script”.\n\n\n\nFig 2. Creating a new R script\n\n\nWe can now edit the script. Here, we enter each of the computations we want R to do as a single line of our script. Once all four lines are ready, we select them all (either by marking them with the mouse or by clicking ctrl+a). We then tell RStudio to run the selected code by clicking on the “Run”-button on the top right above the script or by pushing ctrl+Enter.\n\n\n\nFig 3. Running the code contained in the R script\n\n\nAs we can see, the output in the console looks as if we had manually entered the code and pressed “Enter” after each line. We could have obtained the same result by copy-pasting the content of the script into the console and hitting “Enter”.\nIn the image above, our script is yet unsaved as can be seen from its name “untitled1”. We can save it by clicking on the floppy disc Symbol (for those of you who still know what a 3.5” floppy disc is) or by clicking on “File” and then “Save” or “Save as”. Since we have not yet named our script, we will be prompted to select a name and to choose in which folder we want to save the script.\nFor example, we can name this script “my first script”. Once we have done that, the tab above the script shows the name of the script (or the start of the name if we chose a long name) followed by “.R” indicating that this is an R file.\n Also note how the name of the script is now shown in black font as opposed to the red font it had prior to saving. Writing a script’s name in red font is RStudio’s way of telling you that this script has unsaved changes."
  },
  {
    "objectID": "intro2.html#commenting-your-code",
    "href": "intro2.html#commenting-your-code",
    "title": "Running code in R",
    "section": "Commenting your code",
    "text": "Commenting your code\nOne crucial part of an R script are comments. Comments are used to explain the code we write. Commenting our scripts is very important as it provides structure to them and makes the code legible, be it for others who try to understand our code or to ourselves (trust me, you will learn to appreciate a well-commented code if you return to a script you wrote a few months back and cannot remember what you did there).\nWe can write comments by adding a # in front of the text. All text following a # in the same line will be ignored by R when running the script.\n\n\n\nFig 5. Running code with comments\n\n\nWhen running the script the whole code is copied to the console, but only the actual code is being evaluated. All the text that we declared as comments is being ignored.\n\nNote: A good rule of thumb is to have at least one line of comments for every four lines of code. When in doubt, opt for more or more detailed comments. Better to over-explain your code than to risk it being unintelligible."
  },
  {
    "objectID": "intro3.html",
    "href": "intro3.html",
    "title": "Objects and functions",
    "section": "",
    "text": "R revolves around objects and functions. Generally speaking, an object is a container for information, and a function is a piece of code that performs a specific task. We often use functions to manipulate or create objects."
  },
  {
    "objectID": "intro3.html#r-objects",
    "href": "intro3.html#r-objects",
    "title": "Objects and functions",
    "section": "R objects",
    "text": "R objects\nIn R, an object is information that we tore in R’s memory. In order to define an R object, we need to choose a name and tell R what information the object should contain. The general syntax for defining objects looks like this:\n\nobject_name = information\n\nWe write the name of our new object to the left of an equal sign and define the information the object should contain to its right. Instead of using an equal sign to define an object, we can also draw an arrow using the less than sign and a hyphen, which looks like this:\n\nobject_name <- information\n\n\nUsing the arrow instead of an equal sign dates back to an old programming language that R is derived from (APL). Whether you define objects using arrows or equal signs has no effect on what R does. It is simply a matter of preference.\n\nAs soon as we have defined an object (and assuming that we did everything correctly), our new object will appear in the Environment tab of RStudio’s Memory section (top right panel).\nWe will now cover the most important of the basic R objects, namely:\n\nsingle values\nvectors\nmatrices\n\n\nWe will later turn toward two of the more complex R objects that we are very likely to encounter frequently when working with R:\n\ndata frames\nlists"
  },
  {
    "objectID": "intro3.html#functions-in-r",
    "href": "intro3.html#functions-in-r",
    "title": "Objects and functions",
    "section": "Functions in R",
    "text": "Functions in R\nR functions are predefined pieces of code that we can call by writing the function name and telling R a number of function arguments. Function arguments are pieces of information a function needs to know in order to perform its task (very rarely, a function may not need any argument to perform its task). The general syntax for calling a function looks like this:\n\nfunction_name(argument1, argument2, ...)\n\nThat is, we first write the function’s name, and then define all required arguments in parentheses. If we do that correctly, the function will perform its task. Depending on the function, we will see an output in the console.\nWe will be using two functions below:\n\nThe function c, which we will use to create vectors. The arguments the function c requires are the elements we want to combine into a vector.\nThe function matrix, which creates a matrix from a vector. This functions requires a vector, the number of rows and the number of columns as arguments.\n\n\nCore fact 1: Functions can have a lot of arguments, but it is not always necessary to specify all of them. Most functions have default values for some of their arguments. If we do not specify these arguments, R will just run the function as if we had entered the default value of the argument. If we do specify arguments with default values, we simply override the default.\n\n\nCore fact 2: It is impossible (for most people at least) to remember all functions and which arguments they require. Therefore, R contains a lifesaver in the form of a special function called help. The function help requires the name of a topic (including but not limited to functions) as its main argument. Calling help with the name of a function will show the documentation for that function in the Help tab of the Utility & Help section of RStudio’s interface (bottom right)."
  },
  {
    "objectID": "intro3.html#object-types",
    "href": "intro3.html#object-types",
    "title": "Objects and functions",
    "section": "Object types",
    "text": "Object types\nSingle values, vectors, and matrices can vary by type. The type of these objects refers to the nature of its content, for example whether it contains numbers, character strings, logical arguments etc. The most common types of types are:\n\ndouble: this means numbers with decimal points (although the decimals must not necessarily be displayed)\ninteger: whole numbers that can be negative positive or zero (rarely used because double type numbers are more practical)\ncharacter: a character string, which is essentially a sequence of text symbols (these symbols can include numbers, but these are interpreted as being part of the text and not as numbers)\nlogical: a logical TRUE or FALSE, also called a boolean value"
  },
  {
    "objectID": "intro3.html#single-values",
    "href": "intro3.html#single-values",
    "title": "Objects and functions",
    "section": "Single values",
    "text": "Single values\nSingle values are the simplest type of objects we can define in R. As their name suggests, they represent a single value, for example, the number 7. We could tell R to create a single value called a that consists of the number 7. We do this as follows:\n\na = 7\n\nAlternatively, we can use the arrow notation to define the object.\n\na <- 7\n\nOnce we run either line of code, we should notice that our Environment now contains the object a. There, we can also see that a is the number 7.\nWe can make R show us an object by running its name as code (either via the console or a script). If we enter the name of our single value a as code, we will see the following output.\n\n\n\n[1] 7\n\n\n\nR tells us “7”, which is exactly the value that we specified as a. The “[1]” in front of the value “7” is not important at this point. It merely tells us that the “7” is the first (and only) element of our single value."
  },
  {
    "objectID": "intro3.html#vectors",
    "href": "intro3.html#vectors",
    "title": "Objects and functions",
    "section": "Vectors",
    "text": "Vectors\nVectors are objects that contain multiple values of the same type. Vectors cannot contain elements of different types. We can define vectors using the function c with the function’s arguments being the values we want to combine into the respective vector. The syntax looks as follow:\n\nv1 = c(1,2,3)   # This line of code creates a double vector \n                # called \"v1\" containing the numbers 1 to 3.\n\nv2 = c('hello', 'purple', '11!')  # This creates a character vector\n                                  # called \"v2\" containing three strings.\n\nAfter executing this code, our Environment contains two more objects, v1 and v2. The vector v1 is denoted as a numeric vector (num) whereas v2 is labeled as a character vector (chr).\nJust as with the single value a, we can have a look at our vectors by entering their names as code. For example, we can enter v2 as code.\n\n\n\n[1] \"hello\"  \"purple\" \"11!\"   \n\n\n\nWe now see the three character strings that v2 consists of in the console. Again, there is a [1] at the front of the line. It indicates that “hello” is the first element of v2. If the vector was long enough to occupy multiple rows in the console, each line would start with a number in brackets, indicating which element of the vector is displayed at the beginning of that line.\n\nFun fact: We can think of single values as vectors of length 1.\n\n\nCaveat: If we try to create a vector containing different types of elements, R will not complain (i.e., we do not get an error message)! Instead, R will simply transform some of the elements to ensure that all elements share the same type.\nFor example, if at least one of the elements we want to include in the vector is a character string, R will transform all other element types to character strings and create a character vector.\nIf we try to combine numeric (double or integer) and logical values into one vector, R will interpret “FALSE” as 0 and “TRUE” as 1."
  },
  {
    "objectID": "intro3.html#matrices",
    "href": "intro3.html#matrices",
    "title": "Objects and functions",
    "section": "Matrices",
    "text": "Matrices\nMatrices are the two-dimensional cousins of vectors. They have r rows and c columns. Per convention, the number of rows is stated before the number of columns, that is, a 4x3 matrix has 4 rows and 3 columns (think roman-catholic as a mnemonic aid).\nAs with vectors, all elements of a matrix must share the same type (if we try to combine different types of elements, R will just transform some of the elements to create a homogeneous matrix). In fact, matrices in R are vectors that we break down into rows and columns. To create a matrix, we need to call the function matrix and tell R three arguments: the vector we want to make into a matrix, the number of its rows, and the number of its columns. The syntax looks as follows:\n\nmatrix1 = matrix( # this tells R that we want to create a matrix\n  c(1,2,3,4),     # defines the vector that will turn into a matrix\n  nrow = 2,       # this tells R that our matrix should have 2 rows \n  ncol = 2)       # this tells R that our matrix should have 2 columns\n\nExecuting the code above creates a numerical matrix in our Environment. Other than with single values and vectors, we can click on the name of our matrix in the Environment to view how it looks like. Alternatively, we can enter the name of our matrix as code and have R print it in the console.\n\n\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\n\n\n\nR is convenient in the sense that it is technically sufficient to specify either the number of rows or the number of columns. R will just infer the missing piece of information. For example, if we want to turn a vector of length 6 into a matrix with 2 columns, R will know that the matrix must have 3 rows."
  },
  {
    "objectID": "intro3.html#naming-objects-in-r",
    "href": "intro3.html#naming-objects-in-r",
    "title": "Objects and functions",
    "section": "Naming objects in R",
    "text": "Naming objects in R\nIn order to define an object in R, we need to give it a name and then tell R how the object should look like. Generally speaking, we can get very creative when naming our objects, but there are a few rules we need to keep in mind.\n\nObject names must not start with numbers. The name “item2” is valid, but “2nd” is not (it will return a error message complaining about an “unexpected symbol”).\nObject names may not contain special characters with the exception of underscores and periods. For example, the names “item_2” or “item.2” are valid. Using other special character will often yield error messages because R interprets these characters as operators (e.g., “*” indicates multiplication, “&” is a logical conjunction, etc.).\nObject names must not contain spaces. While “item2” is a valid name, “item 2” is not.\n\n\nNot being allowed to use spaces in object names might prevent us from assigning meaningful and intelligible object names. To deal with the issue, there are three common types of notation:\n\nperiod notation: place periods where you would have placed a space, e.g. trial.number\nunderscore notation: replace spaces with underscores, e.g. trial_number\ncamelBack notation: instead of spaces write everything as one word, but write the beginning of new words with a capital letter, e.g. trialNumber\n\nWhich notation you use is purely a matter of preference. You will likely encounter all of them when using R because the people who created base R or additional packages each have their own preferences regarding notation."
  }
]