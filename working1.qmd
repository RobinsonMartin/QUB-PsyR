---
title: "Single Values"
---

We already know ho to define R objects. We will now turn to the question how to work with them. Generally speaking, we can work with R objects by performing **operations** on them. There are two ways of doing so: one is to use **binary operators**. Binary operators are symbols that R uses to represent a specific operation involving two objects. These operations can be *arithmetic* or *logical*. Another way to perform operations on R objects is to feed them into **functions** as function arguments. 

We can think of a function as an (often) elaborate sequence of simple operations. As such, they can involve more than two objects. However, functions are not only more elaborate than operations using a binary operator; they are also more flexible, because we can modify what a function does or how it does it via its additional function arguments.

:::{.alert .alert-info}
Consider, for example the function *matrix* we used previously. It is flexible because the function arguments *nrow* and *ncol* allow us to create matrices of arbitrary size.
:::

In the following, we will learn how to perform arithmetic and logical operations on single values by using some of R's built-in binary operators and by using functions. But before we jump into action, we need to have a look at how R's binary operators look like.


## Arithmetic binary operators

R has seven built-in arithmetic binary operators (you will probably not use the last two, but we will include them for the sake of completeness).

| Operator| Operation        | What R does                                  |
|---------|------------------|----------------------------------------------|
| +       | addition         | computes the sum of two numbers              |
| -       | subtraction      | subtracts the second number from the first   |
| *       | multiplication   | computes the product of two numbers          |
| -       | division         | divides first number by the second           |
| ^       | power            | takes the first to the power of the second   |
| %%      | modulo           | takes the remainder of division              |
| %/%     | integer division | division rounded down to whole numbers       |

Now that we know the symbols for R's arithmetic binary operators, we can start using them on numeric objects.

Here are a few examples:

```{r}
#| eval: false
#| echo: true
#| code-overflow: wrap
a = 7   # defines a numeric value to play around with
b = 2   # defines a second numeric value

a + 3   # adds 3 to our value for a sum of 10

5 * a   # multiples 5 by a for a product of 35

a ^ b   # computes a to the power of b (49)
```

This is what appears in the console:

:::{.alert .alert-warning}
```{r}
#| eval: true
#| echo: false
a = 7   # defines a numeric value to play around with
b = 2   # defines a second numeric value

a + 3   # adds 3 to our value for a sum of 10

5 * a   # multiples 5 by a for a product of 35

a ^ b   # computes a to the power of b 
```
:::

Of course, we can also use arithmetic operators involving multiple numeric values, and we can save the result by defining it as another object.

:::{.alert .alert-danger}
Note that R follows the basic rules of arithmetic operations. That is, power takes precedence over multiplication or division, which, in turn, take precedence over addition or subtraction. Just as in school maths, we need to use parentheses to organize our operations accordingly.
:::

```{r}
#| eval: true

x = 3   # define a numeric value
y = 2   # define another value

z = x ^ 2 / (x * y - x)
```

In the example above, we defined a numeric value called *z*. Since power takes precedence over division, R first computes *x* to the power of 2 (for a total of 9). It then divides 9 by the expression in the parentheses. Within the parentheses, multiplication takes precedence over subtraction, which means that R first computed the product of *x* and *y* (which is 6) and then subtracts *x* for a total of 3. So our code boils down to dividing 9 by 3. We can easily verify that R did that by inspecting the new object *z*.

```{r}
#| eval: false
#| echo: true
z
```

:::{.alert .alert-warning}
```{r}
#| eval: true
#| echo: false
z
```
:::

:::{.alert .alert-danger}
Arithmetic operators should only work on numeric values (integer or double). Accordingly, R will complain if at lest one of the objects we use as arguments is a character string. Specifically, it will return an error message in the console stating that we assigned a non-numeric argument to the binary operator.

Something similar should happen if we assign at least one boolean value, that is, a value stating either a logical TRUE or FALSE. Keep in mind, however, that R sometimes changes the type of an object so that it works with an operator or function (this is called coercion). If we use a boolean value in an arithmetic operation, R will just treat it as a binary numeric variable (FALSE = 0, TRUE = 1).
:::


## Logical operators

Besides arithmetic operators, R has several built-in logical binary operators. Logical binary operators require two objects as argument and then check if something is TRUE or FALSE. In other word, they return a boolean value. Here is the list of logical operators:

| Operator| What R tests                                                  |  
|---------|---------------------------------------------------------------|
| <       | the first value is **less than** the second                   |
| <=      | the first value is **less than or equal to** the second       |
| >       | the first value is **greater** than the second                |
| >=      | the first value is **greater than or equal to** the second    |
| ==      | the first value is **exactly equal** to the second            |
| !=      | the first value is **not equal** to the second                |

Some of these logical operators can only be used on numeric values or on boolean values that R has coerced to being numeric. However, the last two operators work on any type of value. Here are a few examples:

```{r}
#| eval: false
#| echo: true
#| code-overflow: wrap
a = "hello"   # a character value
b = FALSE     # a boolean value
d = 13        # a numeric value

a != "hello"  # tests if a is unqeual to the string "hello" (this is FALSE)

b == FALSE    # tests if b is the boolean value FALSE (which is TRUE)

d <= 25       # tests if d is less than or equal to 25 (TRUE)

d > b         # tests if 13 is greater than FALSE
              # R will coerce the object b to become numeric with FALSE 
              # equaling 0 (therefore, th statement is TRUE)
```

Here is what the output in the console looks like.

:::{.alert .alert-warning}

```{r}
#| eval: true
#| echo: false
a = "hello"   # a character value
b = FALSE     # a boolean value
d = 13        # a numeric value

a != "hello"  # tests if a is unqeual to the string "hello" (this is FALSE)

b == FALSE    # tests if b is the boolean value FALSE (which is TRUE)

d <= 25       # tests if d is less than or equal to 25 (TRUE)

d > b         # tests if 13 is greater than FALSE
              # R will coerce the object b to become numeric with FALSE 
              # equaling 0 (therefore, th statement is TRUE)
```
:::

:::{.alert .alert-info}
**Note** In the example above, we named the three objects *a*, *b*, and *d*. This was neither an oversight nor an expression of dislike toward the letter *c*. The simple reason is that there is a function called *c*, and it is prudent to avoid giving objects the same name as existing functions.

Technically, it is possible to assign an object the name of a function, but it may lead to confusion or problems. Therefore, it is best avoided.
:::


Just as with numeric binary operators, we can form longer expressions by combining logical operations. There are two ways to connect two logical operations. Each has its own symbol in R. 

| Operator| What it means | What R does                                    |  
|---------|----------------------------------------------------------------|
| &       | **AND**       | return TRUE only if both statements are TRUE   |
| |       | **OR**        | return TRUE if at least one statements is TRUE |

A few examples:

```{r}
#| eval: false
#| echo: true
#| code-overflow: wrap

a == "hello" & d != 7 # tests if both a equal "hello" and d differs from 7
                      # since both statements are true, R will return TRUE

b == FALSE | d == 7   # tests if either b equals FALSE (which is TRUE)
                      # or d equal 7 (which is FALSE); since at least
                      # one of the statements is true, R will return TRUE

a == "bye" | b == TRUE | d != 13  # here, we test if any of three tests is TRUE
                                  # none of them are TRUE, so R will say FALSE
```

Here is what the ourput in the console looks like:

:::{.alert .alert-warning}
```{r}
#| eval: true
#| echo: false

a == "hello" & d != 7 # tests if both a equal "hello" and d differs from 7
                      # since both statements are true, R will return TRUE

b == FALSE | d == 7   # tests if either b equals FALSE (which is TRUE)
                      # or d equal 7 (which is FALSE); since at least
                      # one of the statements is true, R will return TRUE

a == "bye" | b == TRUE | d != 13  # here, we test if any of three tests is TRUE
                                  # none of them are TRUE, so R will say FALSE
```
:::






:::{.alert .alert-info}
The *!* has some special uses in R. It represents the logical argument "non". There are several functions that 


:::